//! ARM Generic Interrupt Controller (GIC) register definitions and basic
//! operations.
//! Driver for the Arm Generic Interrupt Controller version 2 or 3 or 4, on aarch64.
//!
//! This top level module contains functions that are not specific to any particular interrupt
//! controller, as support for other GIC versions may be added in future.
//!
//! Note:
//!  - Interrupt grouping(secure state) is not supported
//!  - Interrupt proiority(preempt) is not supported
//! Please contact the developer if you need this function

#![no_std]
#![feature(const_ptr_as_ref)]
#![feature(const_option)]
#![feature(const_nonnull_new)]
#![feature(pointer_byte_offsets)]
#![feature(const_pointer_byte_offsets)]

use core::fmt;
use core::fmt::{Debug, Formatter};

pub mod gic_v2;
mod gic_v3;
mod sysregs;

pub(crate) mod registers;

pub use crate::gic_v2::GicV2;
pub use crate::gic_v3::GicV3;

// pzc add 5.1
pub use crate::gic_v2::GicHypervisorInterface;
pub use crate::gic_v2::GicDistributor;
use core::ops::Range;
pub const GIC_PPI_NUM: usize = 16;
pub const GIC_SGIS_NUM: usize = 16;
pub const GIC_LIST_REGS_NUM: usize = 64;
pub const GIC_PRIVATE_INT_RANGE: Range<usize> = 0..32;
pub const GIC_PRIVATE_INT_NUM: usize = GIC_SGIS_NUM + GIC_PPI_NUM;

/// An interrupt ID.
#[derive(Copy, Clone, Eq, Ord, PartialOrd, PartialEq)]
pub struct IntId(usize);

impl IntId {
    /// Maximum number of interrupts supported by the GIC.
    pub const GIC_MAX_IRQ: usize = 1020;

    /// The ID of the first Software Generated Interrupt.
    const SGI_START: usize = 0;

    /// The ID of the first Private Peripheral Interrupt.
    const PPI_START: usize = 16;

    /// The ID of the first Shared Peripheral Interrupt.
    const SPI_START: usize = 32;

    /// The first special interrupt ID.
    const SPECIAL_START: usize = 1020;

    /// Returns the interrupt ID for the given Software Generated Interrupt.
    pub const fn sgi(sgi: usize) -> Self {
        assert!(sgi < Self::PPI_START);
        Self(Self::SGI_START + sgi)
    }

    /// Returns the interrupt ID for the given Private Peripheral Interrupt.
    pub const fn ppi(ppi: usize) -> Self {
        assert!(ppi < Self::SPI_START - Self::PPI_START);
        Self(Self::PPI_START + ppi)
    }

    /// Returns the interrupt ID for the given Shared Peripheral Interrupt.
    pub const fn spi(spi: usize) -> Self {
        assert!(spi < Self::SPECIAL_START);
        Self(Self::SPI_START + spi)
    }

    /// Returns whether this interrupt ID is for a Software Generated Interrupt.
    #[allow(dead_code)]
    fn is_sgi(self) -> bool {
        self.0 < Self::PPI_START
    }

    /// Returns whether this interrupt ID is private to a core, i.e. it is an SGI or PPI.
    #[allow(dead_code)]
    fn is_private(self) -> bool {
        self.0 < Self::SPI_START
    }
}

/// Different types of interrupt that the GIC handles.
pub enum InterruptType {
    /// Software-generated interrupt.
    ///
    /// SGIs are typically used for inter-processor communication and are
    /// generated by a write to an SGI register in the GIC.
    SGI,
    /// Private Peripheral Interrupt.
    ///
    /// Peripheral interrupts that are private to one core.
    PPI,
    /// Shared Peripheral Interrupt.
    ///
    /// Peripheral interrupts that can delivered to any connected core.
    SPI,
}

/// Translate an interrupt of a given type to a GIC INTID.
pub const fn translate_irq(id: usize, int_type: InterruptType) -> Option<usize> {
    match int_type {
        InterruptType::SGI => {
            if id < IntId::PPI_START {
                Some(id)
            } else {
                None
            }
        }
        InterruptType::PPI => {
            if id < IntId::SPI_START - IntId::PPI_START {
                Some(id + IntId::PPI_START)
            } else {
                None
            }
        }
        InterruptType::SPI => {
            if id < IntId::SPECIAL_START {
                Some(id + IntId::SPI_START)
            } else {
                None
            }
        }
    }
}

impl Debug for IntId {
    fn fmt(&self, f: &mut Formatter) -> fmt::Result {
        if self.0 < Self::PPI_START {
            write!(f, "SGI {}", self.0 - Self::SGI_START)
        } else if self.0 < Self::SPI_START {
            write!(f, "PPI {}", self.0 - Self::PPI_START)
        } else if self.0 < Self::SPECIAL_START {
            write!(f, "SPI {}", self.0 - Self::SPI_START)
        } else {
            write!(f, "Special IntId {}", self.0)
        }
    }
}

impl From<IntId> for u32 {
    fn from(intid: IntId) -> Self {
        intid.0 as u32
    }
}

impl From<IntId> for usize {
    fn from(intid: IntId) -> Self {
        intid.0
    }
}

impl From<usize> for IntId {
    fn from(id: usize) -> Self {
        Self(id)
    }
}

/// Interrupt trigger mode.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum TriggerMode {
    /// Edge-triggered.
    ///
    /// This is an interrupt that is asserted on detection of a rising edge of
    /// an interrupt signal and then, regardless of the state of the signal,
    /// remains asserted until it is cleared by the conditions defined by this
    /// specification.
    Edge = 0,
    /// Level-sensitive.
    ///
    /// This is an interrupt that is asserted whenever the interrupt signal
    /// level is active, and deasserted whenever the level is not active.
    Level = 1,
}

/// [`GenericArmGic`].
/// It is used to implement the interface abstraction that the interrupt chip
/// driver should provide to the outside world.
/// I hope that the versatility of the driver interface should support more chip architectures.
pub trait GenericArmGic: Debug + Clone + Copy + Sync + Send + Sized {
    /// Initialises the GIC.
    fn init_primary(&mut self);

    fn gicc_init(&mut self) ;

    /// Initialises the GIC for the current CPU core.
    fn per_cpu_init(&mut self);

    /// Configures the trigger type for the interrupt with the given ID.
    fn set_trigger(&mut self, intid: IntId, trigger: TriggerMode);

    /// Enables the interrupt with the given ID.pub fn enable_interrupt(&mut self, intid: IntId);
    fn enable_interrupt(&mut self, intid: IntId);

    /// Disable the interrupt with the given ID.
    fn disable_interrupt(&mut self, intid: IntId);

    /// Gets the ID of the highest priority signalled interrupt, and acknowledges it.
    ///
    /// Returns `None` if there is no pending interrupt of sufficient priority.
    fn get_and_acknowledge_interrupt(&self) -> Option<IntId>;

    /// Informs the interrupt controller that the CPU has completed processing the given interrupt.
    /// This drops the interrupt priority and deactivates the interrupt.
    fn end_interrupt(&self, intid: IntId);

    fn get_iar(&self) -> u32;

    fn set_eoi(&self, iar: u32);

    fn set_dir(&self, irq: u32);

    fn send_sgi(&mut self, cpu_if: usize, sgi_num: usize);

    fn get_priority(&self, int_id: usize) -> usize;

    /// Set interrupt state to pending or not.
    fn set_pend(&self, int_id: usize, is_pend: bool, current_cpu_id: usize);
    
    /// Set interrupt state to active or not.
    fn set_active(&self, int_id: usize, is_active: bool);
    
    /// Set interrupt state. Depend on its active state and pending state.
    fn set_state(&self, int_id: usize, state: usize, current_cpu_id: usize);
    
    /// Get interrupt state. Depend on its active state and pending state.
    fn get_state(&self, int_id: usize) -> usize ;
    
    /// Enables or disables the given interrupt.
    fn set_enable(&mut self, vector: usize, enable: bool);

    /// Determines whether the corresponding interrupt is edge-triggered or level-sensitive.
    fn set_icfgr(&self, int_id: usize, cfg: u8) ;

    /// Set interrupt priority.
    fn set_priority(&mut self, int_id: usize, priority: u8);

    /// Set interrupt target cpu.
    fn set_target_cpu(&mut self, int_id: usize, target: u8) ;


    /// Provides information about the configuration of this Redistributor.
    /// Get typer register.
    fn get_typer(&self) -> u32;

    /// Get iidr register.
    fn get_iidr(&self) -> u32;

    /// Initializes the GIC distributor globally.
    ///
    /// It disables all interrupts, sets the target of all SPIs to CPU 0,
    /// configures all SPIs to be edge-triggered, and finally enables the GICD.
    ///
    /// This function should be called only once.
    fn global_init(&mut self) ;
    /// Initializes the GIC distributor locally.
    ///
    /// It disables and clear all sgi interrupts
    /// configures all interrupts have lowest priority possible by default
    ///
    /// This function should be called every cpu init.
    fn local_init(&mut self) ;

    /// The maximum number of interrupts that the GIC supports
    fn max_irqs(&self) -> usize ;

    /// The number of implemented CPU interfaces.
    fn cpu_num(&self) -> usize ;

    /// Configures the trigger mode for the given interrupt.
    fn configure_interrupt(&mut self, vector: usize, tm: TriggerMode) ;
}


pub const SGI_RANGE: Range<usize> = 0..16;

/* HV */
pub const GIC_TARGET_BITS: usize = 8;
pub const GIC_TARGETS_MAX: usize = GIC_TARGET_BITS;
pub const GIC_CONFIG_BITS: usize = 2;
pub const GIC_PRIO_BITS: usize = 8;
pub const GICD_TYPER_CPUNUM_MSK: usize = 0b11111;
pub const GICD_TYPER_CPUNUM_OFF: usize = 5;

pub const GIC_MAX_IRQ: usize = 1024;

/// Interrupt ID 32-1019 are used for SPIs (Shared Peripheral Interrupt).
///
/// SPI is a peripheral interrupt that the Distributor can route to any of a
/// specified combination of processors.
pub const SPI_RANGE: Range<usize> = 32..1020;